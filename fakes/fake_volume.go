// This file was generated by counterfeiter
package fakes

import (
	"sync"
	"time"

	"github.com/concourse/baggageclaim"
	"github.com/concourse/baggageclaim/volume"
	"github.com/pivotal-golang/clock"
)

type FakeVolume struct {
	HandleStub        func() string
	handleMutex       sync.RWMutex
	handleArgsForCall []struct{}
	handleReturns     struct {
		result1 string
	}
	PathStub        func() string
	pathMutex       sync.RWMutex
	pathArgsForCall []struct{}
	pathReturns     struct {
		result1 string
	}
	TTLStub        func() uint
	tTLMutex       sync.RWMutex
	tTLArgsForCall []struct{}
	tTLReturns     struct {
		result1 uint
	}
	ExpiresAtStub        func() time.Time
	expiresAtMutex       sync.RWMutex
	expiresAtArgsForCall []struct{}
	expiresAtReturns     struct {
		result1 time.Time
	}
	PropertiesStub        func() volume.Properties
	propertiesMutex       sync.RWMutex
	propertiesArgsForCall []struct{}
	propertiesReturns     struct {
		result1 volume.Properties
	}
	HeartbeatStub        func(time.Duration, clock.Clock)
	heartbeatMutex       sync.RWMutex
	heartbeatArgsForCall []struct {
		arg1 time.Duration
		arg2 clock.Clock
	}
	ReleaseStub        func()
	releaseMutex       sync.RWMutex
	releaseArgsForCall []struct{}
}

func (fake *FakeVolume) Handle() string {
	fake.handleMutex.Lock()
	fake.handleArgsForCall = append(fake.handleArgsForCall, struct{}{})
	fake.handleMutex.Unlock()
	if fake.HandleStub != nil {
		return fake.HandleStub()
	} else {
		return fake.handleReturns.result1
	}
}

func (fake *FakeVolume) HandleCallCount() int {
	fake.handleMutex.RLock()
	defer fake.handleMutex.RUnlock()
	return len(fake.handleArgsForCall)
}

func (fake *FakeVolume) HandleReturns(result1 string) {
	fake.HandleStub = nil
	fake.handleReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeVolume) Path() string {
	fake.pathMutex.Lock()
	fake.pathArgsForCall = append(fake.pathArgsForCall, struct{}{})
	fake.pathMutex.Unlock()
	if fake.PathStub != nil {
		return fake.PathStub()
	} else {
		return fake.pathReturns.result1
	}
}

func (fake *FakeVolume) PathCallCount() int {
	fake.pathMutex.RLock()
	defer fake.pathMutex.RUnlock()
	return len(fake.pathArgsForCall)
}

func (fake *FakeVolume) PathReturns(result1 string) {
	fake.PathStub = nil
	fake.pathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeVolume) TTL() uint {
	fake.tTLMutex.Lock()
	fake.tTLArgsForCall = append(fake.tTLArgsForCall, struct{}{})
	fake.tTLMutex.Unlock()
	if fake.TTLStub != nil {
		return fake.TTLStub()
	} else {
		return fake.tTLReturns.result1
	}
}

func (fake *FakeVolume) TTLCallCount() int {
	fake.tTLMutex.RLock()
	defer fake.tTLMutex.RUnlock()
	return len(fake.tTLArgsForCall)
}

func (fake *FakeVolume) TTLReturns(result1 uint) {
	fake.TTLStub = nil
	fake.tTLReturns = struct {
		result1 uint
	}{result1}
}

func (fake *FakeVolume) ExpiresAt() time.Time {
	fake.expiresAtMutex.Lock()
	fake.expiresAtArgsForCall = append(fake.expiresAtArgsForCall, struct{}{})
	fake.expiresAtMutex.Unlock()
	if fake.ExpiresAtStub != nil {
		return fake.ExpiresAtStub()
	} else {
		return fake.expiresAtReturns.result1
	}
}

func (fake *FakeVolume) ExpiresAtCallCount() int {
	fake.expiresAtMutex.RLock()
	defer fake.expiresAtMutex.RUnlock()
	return len(fake.expiresAtArgsForCall)
}

func (fake *FakeVolume) ExpiresAtReturns(result1 time.Time) {
	fake.ExpiresAtStub = nil
	fake.expiresAtReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeVolume) Properties() volume.Properties {
	fake.propertiesMutex.Lock()
	fake.propertiesArgsForCall = append(fake.propertiesArgsForCall, struct{}{})
	fake.propertiesMutex.Unlock()
	if fake.PropertiesStub != nil {
		return fake.PropertiesStub()
	} else {
		return fake.propertiesReturns.result1
	}
}

func (fake *FakeVolume) PropertiesCallCount() int {
	fake.propertiesMutex.RLock()
	defer fake.propertiesMutex.RUnlock()
	return len(fake.propertiesArgsForCall)
}

func (fake *FakeVolume) PropertiesReturns(result1 volume.Properties) {
	fake.PropertiesStub = nil
	fake.propertiesReturns = struct {
		result1 volume.Properties
	}{result1}
}

func (fake *FakeVolume) Heartbeat(arg1 time.Duration, arg2 clock.Clock) {
	fake.heartbeatMutex.Lock()
	fake.heartbeatArgsForCall = append(fake.heartbeatArgsForCall, struct {
		arg1 time.Duration
		arg2 clock.Clock
	}{arg1, arg2})
	fake.heartbeatMutex.Unlock()
	if fake.HeartbeatStub != nil {
		fake.HeartbeatStub(arg1, arg2)
	}
}

func (fake *FakeVolume) HeartbeatCallCount() int {
	fake.heartbeatMutex.RLock()
	defer fake.heartbeatMutex.RUnlock()
	return len(fake.heartbeatArgsForCall)
}

func (fake *FakeVolume) HeartbeatArgsForCall(i int) (time.Duration, clock.Clock) {
	fake.heartbeatMutex.RLock()
	defer fake.heartbeatMutex.RUnlock()
	return fake.heartbeatArgsForCall[i].arg1, fake.heartbeatArgsForCall[i].arg2
}

func (fake *FakeVolume) Release() {
	fake.releaseMutex.Lock()
	fake.releaseArgsForCall = append(fake.releaseArgsForCall, struct{}{})
	fake.releaseMutex.Unlock()
	if fake.ReleaseStub != nil {
		fake.ReleaseStub()
	}
}

func (fake *FakeVolume) ReleaseCallCount() int {
	fake.releaseMutex.RLock()
	defer fake.releaseMutex.RUnlock()
	return len(fake.releaseArgsForCall)
}

var _ baggageclaim.Volume = new(FakeVolume)
